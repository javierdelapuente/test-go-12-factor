//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"gopkg.in/yaml.v2"
)

const CharmcraftName string = "charmcraft.yaml"
const ConfigFileName string = "config_charm.go"

type Charmcraft struct {
	Config struct {
		Options map[string]map[interface{}]interface{}
	}
}

func main() {
	charmcraftPath, err := findFile("..", CharmcraftName)
	if err != nil {
		log.Fatal(err)
	}

	yamlFile, err := os.ReadFile(charmcraftPath)
	if err != nil {
		log.Fatal(err)
	}

	var parsedCharmcraft Charmcraft
	err = yaml.Unmarshal(yamlFile, &parsedCharmcraft)
	if err != nil {
		log.Fatalf("Error unmarshalling: %v", err)
	}

	err = generateConfigFile(parsedCharmcraft, ConfigFileName)
	if err != nil {
		log.Fatalf("Error generating file: %v", err)
	}
}

// TODO THINK IF WE WANT TO FAIL IF THERE ARE TWO FILES NAMED EQUAL.
// For now just return the first one found.
func findFile(rootPath string, name string) (charmcraftPath string, err error) {
	err = filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err == nil && info.Name() == CharmcraftName {
			charmcraftPath = path
			return filepath.SkipAll
		}
		return nil
	})
	if charmcraftPath == "" {
		err = fmt.Errorf("File %s not found in root path %s", name, rootPath)
	}
	return charmcraftPath, err
}

func generateConfigFile(parsedCharmcraft Charmcraft, configFileName string) (err error) {
	buf := bytes.Buffer{}
	fmt.Fprintf(&buf, "// Code generated by \"charm generator\"; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package config\n")

	fmt.Fprintf(&buf, "type ConfigCharm struct{\n")
	for configName := range parsedCharmcraft.Config.Options {
		var envName = "GO_" + strings.Replace(strings.ToUpper(configName), "-", "_", -1)
		configParts := strings.Split(configName, "-")
		for i, val := range configParts {
			runeArray := []rune(val)
			configParts[i] = string(unicode.ToUpper(runeArray[0])) + string(runeArray[1:])
		}
		var fieldName = strings.Join(configParts, "")
		fmt.Fprintf(&buf, "%s string `env:\"%s\"`\n", fieldName, envName)
	}

	fmt.Fprintf(&buf, "}\n")

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("error: internal error: invalid Go generated: %s", err)
		log.Fatal("error: compile the package to analyze the error")
	}

	err = os.WriteFile(configFileName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
	return err
}
